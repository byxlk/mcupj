CCS PCW C Compiler, Version 3.023, 11338

               Filename: d:\embedded\rs485net\source\tstrs485.LST

               ROM used: 1620 (40%)
                         Largest free fragment is 2048
               RAM used: 115 (60%) at main() level
                         126 (66%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   4C6
0003:  NOP
0004:  BTFSS  0A,3
0005:  BCF    0A,4
0006:  BTFSC  0A,3
0007:  BSF    0A,4
0008:  BCF    0A,3
0009:  BTFSC  03,5
000A:  GOTO   00F
000B:  MOVWF  25
000C:  SWAPF  03,W
000D:  MOVWF  26
000E:  GOTO   014
000F:  BCF    03,5
0010:  MOVWF  25
0011:  SWAPF  03,W
0012:  MOVWF  26
0013:  BSF    26,1
0014:  MOVF   0A,W
0015:  MOVWF  2D
0016:  SWAPF  25,F
0017:  MOVF   04,W
0018:  MOVWF  27
0019:  MOVF   20,W
001A:  MOVWF  28
001B:  MOVF   21,W
001C:  MOVWF  29
001D:  MOVF   22,W
001E:  MOVWF  2A
001F:  MOVF   23,W
0020:  MOVWF  2B
0021:  MOVF   24,W
0022:  MOVWF  2C
0023:  BCF    03,5
0024:  BTFSS  0B,5
0025:  GOTO   028
0026:  BTFSC  0B,2
0027:  GOTO   046
0028:  MOVLW  8C
0029:  MOVWF  04
002A:  BTFSS  00,5
002B:  GOTO   02E
002C:  BTFSC  0C,5
002D:  GOTO   048
002E:  MOVF   27,W
002F:  MOVWF  04
0030:  MOVF   28,W
0031:  MOVWF  20
0032:  MOVF   29,W
0033:  MOVWF  21
0034:  MOVF   2A,W
0035:  MOVWF  22
0036:  MOVF   2B,W
0037:  MOVWF  23
0038:  MOVF   2C,W
0039:  MOVWF  24
003A:  MOVF   2D,W
003B:  MOVWF  0A
003C:  BTFSC  0A,4
003D:  BSF    0A,3
003E:  BCF    0A,4
003F:  SWAPF  26,W
0040:  MOVWF  03
0041:  BCF    03,5
0042:  SWAPF  25,W
0043:  BTFSC  26,1
0044:  BSF    03,5
0045:  RETFIE
0046:  BCF    0A,3
0047:  GOTO   0FE
0048:  BCF    0A,3
0049:  GOTO   185
....................  //********************************************************************************* 
.................... // TsRs485.c 
.................... // 
.................... //                      Test of RS485 network protocol 
.................... // 
.................... // 
.................... // Version 1.0 beta  
.................... // 
.................... // Processor: PIC16F87x 
.................... // Compiler: CCS PCM 3.023 
.................... // 
.................... // 
.................... // By: J.Winpenny 
.................... // j.winpenny@ukonline.co.uk 
.................... // 
.................... // 
.................... // 
.................... //********************************************************************************* 
.................... #DEVICE PIC16F873 *=16 
.................... #include <16f873.h> 
....................  //////// Standard Header file for the PIC16F873 device //////////////// 
.................... //#device PIC16F873 
.................... #list 
.................... 
.................... #define MASTER 
....................  
.................... #use delay(clock=4000000) 
*
01A0:  MOVLW  BC
01A1:  MOVWF  04
01A2:  MOVF   00,W
01A3:  BTFSC  03,2
01A4:  GOTO   1B4
01A5:  MOVLW  01
01A6:  MOVWF  21
01A7:  CLRF   20
01A8:  DECFSZ 20,F
01A9:  GOTO   1A8
01AA:  DECFSZ 21,F
01AB:  GOTO   1A7
01AC:  MOVLW  4A
01AD:  MOVWF  20
01AE:  DECFSZ 20,F
01AF:  GOTO   1AE
01B0:  NOP
01B1:  NOP
01B2:  DECFSZ 00,F
01B3:  GOTO   1A5
01B4:  RETLW  00
.................... #fuses HS,NOWDT,PUT,BROWNOUT,NOPROTECT,NOLVP,NOCPD,NOWRT 
....................  
.................... #include <Tst485.h> 
....................   
.................... void Setup(void); 
.................... void ConfigureComms(void); 
....................  
....................  
.................... // EEPROM addresses 
....................  
.................... #define NET_ADDRESS_HIGH 0 
.................... #define NET_ADDRESS_LOW  1 
....................  
.................... #ifndef MASTER 
.................... // PORT Configuration 
.................... #define PortAConfig 0x3F 
.................... #define PortBConfig 0x00 
.................... #define PortCConfig 0x00 
.................... #define PortDConfig 0x00 
.................... #define PortEConfig 0x00 
.................... #else 
.................... // PORT Configuration 
.................... #define PortAConfig 0x00 
.................... #define PortBConfig 0x00 
.................... #define PortCConfig 0x0f 
.................... #define PortDConfig 0x00 
.................... #define PortEConfig 0x00 
.................... #endif 
....................  
....................  
.................... //********************************************************************* 
....................  
....................  
.................... #define TMR0_RELOAD 255         // TMR0 reload value  
.................... //#define TMR0_RELOAD 248       // TMR0 reload value  
....................  
....................  
.................... #BYTE PORTA = 0x05 
.................... #BYTE PORTB = 0x06 
.................... #BYTE PORTC = 0x07 
.................... #BYTE PORTD = 0x08 
.................... #BYTE PORTE = 0x09 
.................... #BYTE RCREG = 0x1a 
.................... #BYTE TXREG = 0x19 
.................... #BYTE STATUS = 0x03 
.................... #BYTE SSPBUF = 0x13 
.................... #BYTE SSPCON = 0x14 
.................... #BYTE SSPCON2 = 0x91 
.................... #BYTE PR2 = 0x92 
.................... #BYTE SSPADD = 0x93 
.................... #BYTE SSPSTAT = 0x94 
.................... #BYTE SPBRG = 0x99 
.................... #BYTE ADCON1 = 0x9f 
.................... #BYTE OPTIONREG = 0x81 
....................  
.................... #BYTE PIE1 = 0x8c 
.................... #BYTE PIR1 = 0x0c 
.................... #BYTE INTCON = 0x0b 
.................... #BYTE TMR0 = 0x101 
.................... #BYTE RCSTA = 0x18 
.................... #BYTE TXSTA = 0x98 
....................  
.................... #BYTE TRISA = 0x85 
.................... #BYTE TRISB = 0x86 
.................... #BYTE TRISC = 0x87 
.................... #BYTE TRISD = 0x88 
.................... #BYTE TRISE = 0x89 
....................  
.................... // INTCON BITS 
.................... #define GIE 7 
.................... #define PEIE 6 
.................... #define T0IE 5 
.................... #define INTE 4 
.................... #define RBIE 3 
.................... #define T0IF 2 
.................... #define INTF 1 
.................... #define RBIF 0 
....................  
.................... // USART Register bits 
.................... #define CSCR 7 
.................... #define TX9  6 
.................... #define TXEN 5 
.................... #define SYNC 4 
.................... #define BRGH 2 
.................... #define TRMT 1 
.................... #define TX9D 0 
.................... #define SPEN 7 
.................... #define RX9  6 
.................... #define SREN 5 
.................... #define CREN 4 
.................... #define ADDEN 3 
.................... #define FERR 2 
.................... #define OERR 1 
.................... #define RX9D 0 
....................  
.................... #define TRMT_MASK 2 
....................  
.................... // Bits of STATUS register 
.................... #define IRP   7 
.................... #define RP1   6 
.................... #define RP0   5 
.................... #define T0    4 
.................... #define PD    3 
.................... #define ZERO  2 
.................... #define DC    1 
.................... #define CARRY 0 
....................  
.................... // Bits of PIE1 
.................... #define PSPIE 7 
.................... #define ADIE 6 
.................... #define RCIE 5 
.................... #define TXIE 4 
.................... #define SSPIE 3 
.................... #define CCP1IE 2 
.................... #define TMR2IE 1 
.................... #define TMR1IE 0 
....................  
.................... // Bits of SSPSTAT 
.................... #define SMP 7 
.................... #define CKE 6 
.................... #define D_A 5 
.................... //#define P   4 // Cause compiler error because of identifier s 
.................... //#define S   3 
.................... #define R_W 2 
.................... #define R_W_MASK 0x04 
.................... #define UA  1 
.................... #define BF  0 
....................  
.................... // Bits of PIR1 
.................... #define PSPIF  7 
.................... #define ADIF   6 
.................... #define RCIF   5 
.................... #define TXIF   4 
.................... #define SSPIF  3 
.................... #define SSPIF_MASK 0x08 
.................... #define CCP1IF 2 
.................... #define TMR2IF 1 
.................... #define TMR1IF 0 
....................  
.................... // Bits of SSPCON2 
....................  
.................... #define GCEN    7 
.................... #define ACKSTAT 6 
.................... #define ACKDT   5 
.................... #define ACKEN   4 
.................... #define RCEN    3 
.................... #define PEN     2 
.................... #define RSEN    1 
.................... #define SEN     0 
.................... 
.................... #include <stdlib.h> 
....................  ////        (C) Copyright 1996,1997 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _stdlib_ 
....................  
.................... #define _stdlib_ true 
....................  
.................... float atof(char * s) { 
....................  float pow10; 
....................         float result; 
....................  int sign, point; 
....................  char c; 
....................         int ptr; 
....................  
....................         ptr=0; 
....................     sign = 0; 
....................  point = 0; 
....................  pow10 = 1.0; 
....................     result = 0.0; 
....................  
....................  do 
....................           c=s[ptr++]; 
....................         while ((c<'0'||c>'9') && c!='+' && c!='-' && c!='.'); 
....................  
....................  while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................            if(c == '-') { 
....................               sign = 1; 
....................               c = s[ptr++]; 
....................            } 
....................  
....................            while((c >= '0' && c <= '9') && point == 0) { 
....................               result = 10*result + c - '0'; 
....................               c = s[ptr++]; 
....................            } 
....................  
....................            if (c == '.') { 
....................               point = 1; 
....................               c = s[ptr++]; 
....................            } 
....................  
....................     while((c >= '0' && c <= '9') && point == 1) { 
....................         pow10 = pow10*10; 
....................                result += (c - '0')/pow10; 
....................                c = s[ptr++]; 
....................            } 
....................         } 
....................  
....................  if (sign == 1) 
....................       result = -1*result; 
....................  
....................  return(result); 
.................... } 
....................  
.................... #define labs abs 
.................... #define fabs abs 
....................  
.................... /************************************************************/ 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    // Omit all preceeding alpha characters 
....................    do 
....................       c = s[index++]; 
....................    while ((c < '0' || c > '9') && c != '+' && c != '-'); 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          while (c = TOUPPER(c), (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
....................  
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    do 
....................       c = s[index++]; 
....................    while ((c < '0' || c>'9') && c != '+' && c != '-'); 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          while (c = TOUPPER(c), (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    do 
....................       c = s[index++]; 
....................    while ((c < '0' || c>'9') && c != '+' && c != '-'); 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          while (c = TOUPPER(c), (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
....................  
.................... #endif 
.................... 
.................... #include <Rs485.c>    // RS485 packet protocol driver 
....................  //************************************************************************** 
.................... // Rs495.c 
.................... //                      RS485 network protocol 
.................... // 
.................... // Version 1.0 beta 
.................... // 
.................... // Processor: PIC16F87x 
.................... // 
.................... // Network packet protocol: 
.................... // 
.................... // STX ( 0x02 ) 
.................... // NET ADDRESS HIGH   
.................... // NET ADDRESS LOW 
.................... // PAYLOAD LENGTH 
.................... // COMMAND 
.................... // DATA ( Optional ) 
.................... // CRC HIGH 
.................... // CRC LOW 
.................... // 
.................... // 
.................... // 
.................... // 
.................... // 
.................... // By: J.Winpenny 
.................... // j.winpenny@ukonline.co.uk 
.................... // 
.................... //************************************************************************** 
.................... #include <Rs485.h> 
....................  #separate 
.................... char Rs485Process(void); 
.................... void Rs485Initialise(char cAddrHigh, char cAddrLow); 
.................... #separate 
.................... char Rs485Decode( void ); 
.................... void Rs485UpdateCrc(char cVal ); 
.................... void CRC16_Init( void ); 
.................... void CRC16_Update4Bits( char val ); 
.................... void Rs485SendPacket( char cCmd, char cLen, char *cData ); 
.................... void Rs485GetPacket( char *cCom, char *cLen, char *cData ); 
.................... void Rs485SendChar( char c ); 
.................... char PostValidatePacket(void); 
.................... char PacketHasPayload(void); 
.................... void BinToHexAscii( char c ); 
....................  
....................  
.................... #define NULL 0 
....................  
.................... // Configurables 
.................... #define RS485_CONTROL PORTC 
.................... #define OUTPUTS_ON 5 
.................... #define NUM_TX_PREAMBLE 3 
....................  
....................  
.................... // Protocol defines 
.................... #define PKT_START 0x02 
....................  
.................... // States of packet decoder state machine 
.................... #define PKT_WAIT_START      0 
.................... #define PKT_WAIT_ADDR_HIGH  1 
.................... #define PKT_WAIT_ADDR_LOW   2 
.................... #define PKT_WAIT_LEN        3 
.................... #define PKT_CMD             4 
.................... #define PKT_WAIT_DATA       5 
.................... #define PKT_WAIT_CRC_HIGH   6 
.................... #define PKT_WAIT_CRC_LOW    7 
.................... #define PKT_COMPLETE        8 
.................... #define PKT_VALID           9 
.................... #define PKT_INVALID       255 
....................  
.................... // Error codes 
.................... #define BAD_LENGTH 1 
.................... #define BAD_CRC    2 
....................  
....................  
.................... // Packet types 
.................... #define SENSOR_POLL_CMD        0xA1 
.................... #define SENSOR_PING_SYNC       0xA2 
.................... #define SENSOR_CONFIG          0xA3 
.................... #define SENSOR_GET_DATA        0xA4 
....................  
....................  
....................  
.................... #define SENSOR_ACK             0xB0 
.................... #define SENSOR_NAK             0xC0 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... 
.................... #include <lcd2.h> 
....................  /***********************************************/ 
.................... /* LCD.H   Header for LCD routines             */ 
.................... /***********************************************/ 
....................  
....................    void WaitBusyFlag(void); 
....................    void LCDSetup(void); 
....................    void FunctionMode(void); 
....................    void DataMode(void); 
....................    void Write_8_Bit( char dh ); 
....................    void LcdWrite(char dl ); 
....................    void Delay(void); 
....................    void Clear(void); 
....................    void SetPos(char Pos); 
....................    void Line1(void); 
....................    void Line2(void); 
....................    void ClearLine1(void); 
....................    void ClearLine2(void); 
....................    void WriteString( char *lcdptr ); 
....................  
.................... 
.................... // #include <lcd873.h> 
....................  
....................  
....................  
.................... //struct 
.................... //{ 
.................... static char cOurAddrHigh; 
.................... static char cOurAddrLow; 
.................... static char cRs485RxChar; 
.................... static char cRS485State; 
....................  
.................... static char cStart; 
.................... static char cNetAddrHigh, cNetAddrLow; 
.................... static char cLenExpected; 
.................... static char cCommand; 
.................... static char c485Buf[64]; 
.................... static char cRxCrcHigh, cRxCrcLow; 
.................... static char cCalcCrcHigh, cCalcCrcLow; 
.................... static char cBufPtr; 
.................... static char cError; 
.................... static char cCrcTmp, cCrcTmp5, cCrcTmp4, cCrcTmp3, cCrcTmp2; 
.................... //} RS485_Protocol; 
....................  
....................  
.................... //**************************************************************************** 
.................... // void Rs485Initialise(void) 
.................... // 
.................... // Initialise RS485 network driver 
.................... //**************************************************************************** 
.................... void Rs485Initialise(char cAddrHigh, char cAddrLow) 
.................... { 
....................   cOurAddrHigh = cAddrHigh; 
*
025D:  BSF    03,5
025E:  MOVF   32,W
025F:  BCF    03,5
0260:  MOVWF  2E
....................   cOurAddrLow = cAddrLow; 
0261:  BSF    03,5
0262:  MOVF   33,W
0263:  BCF    03,5
0264:  MOVWF  2F
....................   cRS485State = PKT_WAIT_START; 
0265:  CLRF   31
....................   BIT_CLEAR( RS485_CONTROL, OUTPUTS_ON );           // Disable driver 
0266:  BCF    07,5
....................   BIT_SET( PIE1, RCIE );                            // Enable Receive Interrupt 
0267:  BSF    03,5
0268:  BSF    0C,5
0269:  BCF    03,5
026A:  RETLW  00
.................... } 
....................  
....................  
.................... //**************************************************************************** 
.................... // char PacketForUs(void) 
.................... // 
.................... // Decide if packet valid and destined for this node. 
.................... // Ignore invalid packets and packets for other nodes 
.................... // 
.................... //**************************************************************************** 
.................... #separate 
.................... char Rs485Process(void) 
.................... { 
.................... char cOurPkt, cPktReady; 
....................  
....................     cOurPkt = FALSE; 
*
0392:  BSF    03,5
0393:  CLRF   32
....................     cPktReady = FALSE; 
0394:  CLRF   33
....................  
....................     disable_interrupts(GLOBAL); 
0395:  BCF    03,5
0396:  BCF    0B,6
0397:  BCF    0B,7
0398:  BTFSC  0B,7
0399:  GOTO   397
....................  
....................     if ( cRS485State == PKT_COMPLETE ) 
039A:  MOVF   31,W
039B:  SUBLW  08
039C:  BTFSS  03,2
039D:  GOTO   485
....................     { 
....................        	if ( ( cNetAddrHigh == cOurAddrHigh )&&   // Invalid and destined for this node 
.................... 					( cNetAddrLow == cOurAddrLow ) ) 
039E:  MOVF   2E,W
039F:  SUBWF  33,W
03A0:  BTFSS  03,2
03A1:  GOTO   3AC
03A2:  GOTO   3A3
03A3:  MOVF   2F,W
03A4:  SUBWF  34,W
03A5:  BTFSS  03,2
03A6:  GOTO   3AC
.................... 			{ 
.................... 			   cOurPkt = TRUE; 
03A7:  MOVLW  01
03A8:  BSF    03,5
03A9:  MOVWF  32
.................... 			} 
.................... 			else 
03AA:  BCF    03,5
03AB:  GOTO   3C2
.................... 			{ 
.................... 			   ClearLine2(); 
03AC:  CALL   27D
.................... 			   LcdWrite("traffic");                  // Network traffic for other nodes 
*
004A:  BCF    0A,0
004B:  BCF    0A,1
004C:  BCF    0A,2
004D:  ADDWF  02,F
004E:  RETLW  74
004F:  RETLW  72
0050:  RETLW  61
0051:  RETLW  66
0052:  RETLW  66
0053:  RETLW  69
0054:  RETLW  63
0055:  RETLW  00
*
03AD:  BSF    03,5
03AE:  CLRF   34
03AF:  BCF    03,5
03B0:  BSF    03,5
03B1:  MOVF   34,W
03B2:  BCF    03,5
03B3:  CALL   04A
03B4:  IORLW  00
03B5:  BTFSC  03,2
03B6:  GOTO   3BD
03B7:  BSF    03,5
03B8:  INCF   34,F
03B9:  MOVWF  3A
03BA:  BCF    03,5
03BB:  CALL   1C9
03BC:  GOTO   3B0
....................             delay_ms(200); 
03BD:  MOVLW  C8
03BE:  BSF    03,5
03BF:  MOVWF  3C
03C0:  BCF    03,5
03C1:  CALL   1A0
....................       	} 
....................  
....................       cRS485State = PostValidatePacket();         // Validate packet CRC 
*
043A:  MOVF   21,W
043B:  MOVWF  31
....................  
.................... 		if ( (cRS485State == PKT_INVALID)||(cRS485State == PKT_VALID) ) 
043C:  INCFSZ 31,W
043D:  GOTO   43F
043E:  GOTO   443
043F:  MOVF   31,W
0440:  SUBLW  09
0441:  BTFSS  03,2
0442:  GOTO   485
.................... 		{ 
.................... 			// Reject invalid packets 
.................... 			if ( cRS485State == PKT_INVALID )          // NAK our invalid packets 
0443:  INCFSZ 31,W
0444:  GOTO   474
.................... 			{ 
.................... 			   ClearLine2(); 
0445:  CALL   27D
.................... 			   if ( cError == BAD_CRC ) LcdWrite("Bad CRC"); 
*
0056:  BCF    0A,0
0057:  BCF    0A,1
0058:  BCF    0A,2
0059:  ADDWF  02,F
005A:  RETLW  42
005B:  RETLW  61
005C:  RETLW  64
005D:  RETLW  20
005E:  RETLW  43
005F:  RETLW  52
0060:  RETLW  43
0061:  RETLW  00
*
0446:  MOVF   7C,W
0447:  SUBLW  02
0448:  BTFSS  03,2
0449:  GOTO   45B
044A:  BSF    03,5
044B:  CLRF   34
044C:  BCF    03,5
044D:  BSF    03,5
044E:  MOVF   34,W
044F:  BCF    03,5
0450:  CALL   056
0451:  IORLW  00
0452:  BTFSC  03,2
0453:  GOTO   45A
0454:  BSF    03,5
0455:  INCF   34,F
0456:  MOVWF  3A
0457:  BCF    03,5
0458:  CALL   1C9
0459:  GOTO   44D
....................             else if ( cError == BAD_LENGTH ) LcdWrite("Bad length"); 
*
0062:  BCF    0A,0
0063:  BCF    0A,1
0064:  BCF    0A,2
0065:  ADDWF  02,F
0066:  RETLW  42
0067:  RETLW  61
0068:  RETLW  64
0069:  RETLW  20
006A:  RETLW  6C
006B:  RETLW  65
006C:  RETLW  6E
006D:  RETLW  67
006E:  RETLW  74
006F:  RETLW  68
0070:  RETLW  00
*
045A:  GOTO   46D
045B:  DECFSZ 7C,W
045C:  GOTO   46D
045D:  BSF    03,5
045E:  CLRF   34
045F:  BCF    03,5
0460:  BSF    03,5
0461:  MOVF   34,W
0462:  BCF    03,5
0463:  CALL   062
0464:  IORLW  00
0465:  BTFSC  03,2
0466:  GOTO   46D
0467:  BSF    03,5
0468:  INCF   34,F
0469:  MOVWF  3A
046A:  BCF    03,5
046B:  CALL   1C9
046C:  GOTO   460
....................             delay_ms(200); 
046D:  MOVLW  C8
046E:  BSF    03,5
046F:  MOVWF  3C
0470:  BCF    03,5
0471:  CALL   1A0
.................... 			   //if ( cOurPkt ) Rs485SendPacket( SENSOR_NAK, 0, NULL ); 
.................... 			   cRS485State = PKT_WAIT_START; 
0472:  CLRF   31
.................... 			} 
.................... 			else if ( cRS485State == PKT_VALID )       // If packet valid 
0473:  GOTO   485
0474:  MOVF   31,W
0475:  SUBLW  09
0476:  BTFSS  03,2
0477:  GOTO   485
.................... 			{                                          // and destined for this node 
.................... 			   if ( cOurPkt ) cPktReady = TRUE; 
0478:  BSF    03,5
0479:  MOVF   32,F
047A:  BTFSS  03,2
047B:  GOTO   47E
047C:  BCF    03,5
047D:  GOTO   484
047E:  BCF    03,5
047F:  MOVLW  01
0480:  BSF    03,5
0481:  MOVWF  33
.................... 			   else  cRS485State = PKT_WAIT_START; 
0482:  BCF    03,5
0483:  GOTO   485
0484:  CLRF   31
.................... 			} 
.................... 		} 
....................    } 
....................  
....................    enable_interrupts(GLOBAL); 
0485:  MOVLW  C0
0486:  IORWF  0B,F
....................  
....................  return cPktReady; 
0487:  BSF    03,5
0488:  MOVF   33,W
0489:  BCF    03,5
048A:  MOVWF  21
048B:  BCF    0A,3
048C:  GOTO   5D2
....................  
.................... } 
....................  
....................  
.................... //**************************************************************************** 
.................... // void Rs485Decode(void) 
.................... // 
.................... // Decode an incomming packet on the RS485 network 
.................... // 
.................... // Expecting: 
.................... // START, 
.................... // NETWORK ADDRESS_HIGH, 
.................... // NETWORK ADDRESS_LOW, 
.................... // PAYLOAD LENGTH, 
.................... // COMMAND, 
.................... // optional DATA, 
.................... // CRC HIGH, 
.................... // CRC LOW 
.................... // 
.................... //**************************************************************************** 
.................... #separate 
.................... char Rs485Decode( void ) 
.................... { 
....................  
....................    switch ( cRS485State ) 
*
0112:  MOVF   31,W
0113:  MOVWF  20
0114:  BTFSC  03,2
0115:  GOTO   13F
0116:  MOVLW  01
0117:  SUBWF  20,W
0118:  BTFSC  03,2
0119:  GOTO   146
011A:  MOVLW  02
011B:  SUBWF  20,W
011C:  BTFSC  03,2
011D:  GOTO   14A
011E:  MOVLW  03
011F:  SUBWF  20,W
0120:  BTFSC  03,2
0121:  GOTO   14E
0122:  MOVLW  04
0123:  SUBWF  20,W
0124:  BTFSC  03,2
0125:  GOTO   15C
0126:  MOVLW  05
0127:  SUBWF  20,W
0128:  BTFSC  03,2
0129:  GOTO   168
012A:  MOVLW  06
012B:  SUBWF  20,W
012C:  BTFSC  03,2
012D:  GOTO   173
012E:  MOVLW  07
012F:  SUBWF  20,W
0130:  BTFSC  03,2
0131:  GOTO   177
0132:  MOVLW  08
0133:  SUBWF  20,W
0134:  BTFSC  03,2
0135:  GOTO   17C
0136:  MOVLW  09
0137:  SUBWF  20,W
0138:  BTFSC  03,2
0139:  GOTO   17D
013A:  MOVLW  FF
013B:  SUBWF  20,W
013C:  BTFSC  03,2
013D:  GOTO   17E
013E:  GOTO   17F
....................    { 
....................         case    PKT_WAIT_START:  cStart = cRs485RxChar; 
013F:  MOVF   30,W
0140:  MOVWF  32
....................                                  if ( cRs485RxChar == PKT_START ) // Check for the start of packet byte 
0141:  MOVF   30,W
0142:  SUBLW  02
0143:  BTFSC  03,2
....................                                  { 
....................                                     cRS485State++; 
0144:  INCF   31,F
....................                                  } 
....................                                  break; 
0145:  GOTO   181
....................  
....................         case PKT_WAIT_ADDR_HIGH: cNetAddrHigh = cRs485RxChar; 
0146:  MOVF   30,W
0147:  MOVWF  33
....................                                  cRS485State++; 
0148:  INCF   31,F
....................                                  break; 
0149:  GOTO   181
....................  
....................         case  PKT_WAIT_ADDR_LOW: cNetAddrLow = cRs485RxChar; 
014A:  MOVF   30,W
014B:  MOVWF  34
....................                                  cRS485State++; 
014C:  INCF   31,F
....................                                  break; 
014D:  GOTO   181
....................  
....................         case       PKT_WAIT_LEN: cLenExpected = cRs485RxChar; 
014E:  MOVF   30,W
014F:  MOVWF  35
....................                                  if ( cLenExpected > sizeof(c485Buf) ) 
0150:  MOVF   35,W
0151:  SUBLW  40
0152:  BTFSC  03,0
0153:  GOTO   159
....................                                  { 
....................                                     cRS485State = PKT_INVALID; 
0154:  MOVLW  FF
0155:  MOVWF  31
....................                                     cError = BAD_LENGTH; 
0156:  MOVLW  01
0157:  MOVWF  7C
....................                                  } 
....................                                  else 
0158:  GOTO   15B
....................                                  { 
....................                                    cBufPtr = 0; 
0159:  CLRF   7B
....................                                    cRS485State++; 
015A:  INCF   31,F
....................                                  } 
....................                                  break; 
015B:  GOTO   181
....................  
....................         case           PKT_CMD:  cCommand = cRs485RxChar; 
015C:  MOVF   30,W
015D:  MOVWF  36
....................                                  if ( PacketHasPayload() ) cRS485State = PKT_WAIT_DATA; 
015E:  CALL   106
015F:  MOVF   21,F
0160:  BTFSC  03,2
0161:  GOTO   165
0162:  MOVLW  05
0163:  MOVWF  31
....................                                  else cRS485State = PKT_WAIT_CRC_HIGH; 
0164:  GOTO   167
0165:  MOVLW  06
0166:  MOVWF  31
....................                                  break; 
0167:  GOTO   181
....................  
....................         case     PKT_WAIT_DATA:  c485Buf[cBufPtr] = cRs485RxChar; 
0168:  MOVLW  37
0169:  ADDWF  7B,W
016A:  MOVWF  04
016B:  MOVF   30,W
016C:  MOVWF  00
....................                                  cBufPtr++; 
016D:  INCF   7B,F
....................                                  if ( cBufPtr == cLenExpected ) // If last byte of data received 
016E:  MOVF   35,W
016F:  SUBWF  7B,W
0170:  BTFSC  03,2
....................                                  { 
....................                                    cRS485State++;               // next byet is the CRC high byte 
0171:  INCF   31,F
....................                                  } 
....................                                  break; 
0172:  GOTO   181
....................  
....................         case PKT_WAIT_CRC_HIGH:  cRxCrcHigh = cRs485RxChar; 
0173:  MOVF   30,W
0174:  MOVWF  77
....................                                  cRS485State++; 
0175:  INCF   31,F
....................                                  break; 
0176:  GOTO   181
....................  
....................         case  PKT_WAIT_CRC_LOW:  cRxCrcLow = cRs485RxChar; 
0177:  MOVF   30,W
0178:  MOVWF  78
....................                                  cRS485State = PKT_COMPLETE; 
0179:  MOVLW  08
017A:  MOVWF  31
....................                                  break; 
017B:  GOTO   181
....................  
....................         case      PKT_COMPLETE:  break;       // Idle state 
017C:  GOTO   181
....................         case         PKT_VALID:  break;       // Idle state 
017D:  GOTO   181
....................         case       PKT_INVALID:  break;       // Idle state 
017E:  GOTO   181
....................  
....................         default:                 cRS485State = PKT_WAIT_START; 
017F:  CLRF   31
....................                                  break; 
0180:  GOTO   181
....................      } 
....................  
....................  return cRS485State; 
0181:  MOVF   31,W
0182:  MOVWF  21
0183:  BCF    0A,3
0184:  GOTO   193
.................... } 
....................  
....................  
.................... //**************************************************************************** 
.................... // void Rs485SendPacket( char cAddr, char cCmd, char cLen, char *cData ) 
.................... // 
.................... // Send a packet over the RS485 link 
.................... // 
.................... // Input: NETWORK_ADDRESS, COMMAND, PAYLOAD_LENGTH, optional DATA 
.................... // 
.................... //**************************************************************************** 
.................... void Rs485SendPacket( char cCmd, char cLen, char *cData ) 
.................... { 
.................... char c, d; 
....................  
....................    BIT_CLEAR( PIE1, RCIE );                          // Disable Receive Interrupt 
*
02DB:  BSF    03,5
02DC:  BCF    0C,5
....................    BIT_SET( RS485_CONTROL, OUTPUTS_ON );             // Enable driver 
02DD:  BCF    03,5
02DE:  BSF    07,5
....................  
....................    delay_ms(1);                                      // Line turnarround time 
02DF:  MOVLW  01
02E0:  BSF    03,5
02E1:  MOVWF  3C
02E2:  BCF    03,5
02E3:  CALL   1A0
....................  
....................    cCalcCrcHigh = 0xff;                              // Clear CRC 
02E4:  MOVLW  FF
02E5:  MOVWF  79
....................    cCalcCrcLow = 0xff; 
02E6:  MOVWF  7A
....................                                                      // Send some NULL preamblesfopr receiving UART 
....................    for ( c=0; c < NUM_TX_PREAMBLE; c++ ) Rs485SendChar( 0x00 ); 
02E7:  BSF    03,5
02E8:  CLRF   35
02E9:  BCF    03,5
02EA:  BSF    03,5
02EB:  MOVF   35,W
02EC:  SUBLW  02
02ED:  BTFSC  03,0
02EE:  GOTO   2F1
02EF:  BCF    03,5
02F0:  GOTO   2FA
02F1:  BCF    03,5
02F2:  BSF    03,5
02F3:  CLRF   37
02F4:  BCF    03,5
02F5:  CALL   294
02F6:  BSF    03,5
02F7:  INCF   35,F
02F8:  BCF    03,5
02F9:  GOTO   2EA
....................  
....................    Rs485UpdateCrc( PKT_START ); 
02FA:  MOVLW  02
02FB:  BSF    03,5
02FC:  MOVWF  37
02FD:  BCF    03,5
02FE:  CALL   2CA
....................    Rs485SendChar( PKT_START );       // Send packet start character 
02FF:  MOVLW  02
0300:  BSF    03,5
0301:  MOVWF  37
0302:  BCF    03,5
0303:  CALL   294
....................    Rs485UpdateCrc( cOurAddrHigh ); 
0304:  MOVF   2E,W
0305:  BSF    03,5
0306:  MOVWF  37
0307:  BCF    03,5
0308:  CALL   2CA
....................    Rs485SendChar( cOurAddrHigh );    // Send address high 
0309:  MOVF   2E,W
030A:  BSF    03,5
030B:  MOVWF  37
030C:  BCF    03,5
030D:  CALL   294
....................    Rs485UpdateCrc( cOurAddrLow ); 
030E:  MOVF   2F,W
030F:  BSF    03,5
0310:  MOVWF  37
0311:  BCF    03,5
0312:  CALL   2CA
....................    Rs485SendChar( cOurAddrLow );     // Send address low 
0313:  MOVF   2F,W
0314:  BSF    03,5
0315:  MOVWF  37
0316:  BCF    03,5
0317:  CALL   294
....................    Rs485UpdateCrc( cLen ); 
0318:  BSF    03,5
0319:  MOVF   33,W
031A:  MOVWF  37
031B:  BCF    03,5
031C:  CALL   2CA
....................    Rs485SendChar( cLen );            // Send length 
031D:  BSF    03,5
031E:  MOVF   33,W
031F:  MOVWF  37
0320:  BCF    03,5
0321:  CALL   294
....................    Rs485UpdateCrc( cCmd ); 
0322:  BSF    03,5
0323:  MOVF   32,W
0324:  MOVWF  37
0325:  BCF    03,5
0326:  CALL   2CA
....................    Rs485SendChar( cCmd );            // Send command 
0327:  BSF    03,5
0328:  MOVF   32,W
0329:  MOVWF  37
032A:  BCF    03,5
032B:  CALL   294
....................  
....................  
....................    if ( cLen != 0 )                  // If payload not empty send data 
032C:  BSF    03,5
032D:  MOVF   33,F
032E:  BTFSS  03,2
032F:  GOTO   332
0330:  BCF    03,5
0331:  GOTO   365
0332:  BCF    03,5
....................    { 
....................      for ( c = 0; c < cLen; c++ ) 
0333:  BSF    03,5
0334:  CLRF   35
0335:  BCF    03,5
0336:  BSF    03,5
0337:  MOVF   33,W
0338:  SUBWF  35,W
0339:  BTFSS  03,0
033A:  GOTO   33D
033B:  BCF    03,5
033C:  GOTO   34C
033D:  BCF    03,5
....................      { 
....................         d = cData[c]; 
033E:  BSF    03,5
033F:  MOVF   34,W
0340:  ADDWF  35,W
0341:  MOVWF  04
0342:  MOVF   00,W
0343:  MOVWF  36
....................         Rs485UpdateCrc( d ); 
0344:  MOVF   36,W
0345:  MOVWF  37
0346:  BCF    03,5
0347:  CALL   2CA
....................      } 
0348:  BSF    03,5
0349:  INCF   35,F
034A:  BCF    03,5
034B:  GOTO   336
....................      for ( c = 0; c < cLen; c++ ) 
034C:  BSF    03,5
034D:  CLRF   35
034E:  BCF    03,5
034F:  BSF    03,5
0350:  MOVF   33,W
0351:  SUBWF  35,W
0352:  BTFSS  03,0
0353:  GOTO   356
0354:  BCF    03,5
0355:  GOTO   365
0356:  BCF    03,5
....................      { 
....................         d = cData[c]; 
0357:  BSF    03,5
0358:  MOVF   34,W
0359:  ADDWF  35,W
035A:  MOVWF  04
035B:  MOVF   00,W
035C:  MOVWF  36
....................         Rs485SendChar( d );          // Send data 
035D:  MOVF   36,W
035E:  MOVWF  37
035F:  BCF    03,5
0360:  CALL   294
....................      } 
0361:  BSF    03,5
0362:  INCF   35,F
0363:  BCF    03,5
0364:  GOTO   34F
....................    } 
....................  
....................    Rs485SendChar(cCalcCrcHigh); 
0365:  MOVF   79,W
0366:  BSF    03,5
0367:  MOVWF  37
0368:  BCF    03,5
0369:  CALL   294
....................    Rs485SendChar(cCalcCrcLow); 
036A:  MOVF   7A,W
036B:  BSF    03,5
036C:  MOVWF  37
036D:  BCF    03,5
036E:  CALL   294
....................  
....................    delay_ms(1); 
036F:  MOVLW  01
0370:  BSF    03,5
0371:  MOVWF  3C
0372:  BCF    03,5
0373:  CALL   1A0
....................    BIT_CLEAR( RS485_CONTROL, OUTPUTS_ON );           // Disable driver 
0374:  BCF    07,5
....................    BIT_SET( PIE1, RCIE );                            // Enable Receive Interrupt 
0375:  BSF    03,5
0376:  BSF    0C,5
0377:  BCF    03,5
0378:  RETLW  00
.................... } 
....................  
....................  
.................... //**************************************************************************** 
.................... // void Rs485GetPacket( char *cCommand, char cLen, char *cData ) 
.................... // 
.................... // Pass packet to main application 
.................... // 
.................... //**************************************************************************** 
.................... void Rs485GetPacket( char *cCom, char *cLen, char *cData ) 
.................... { 
.................... char c; 
....................  
....................   *cCom = cCommand; 
*
048D:  BSF    03,5
048E:  MOVF   32,W
048F:  MOVWF  04
0490:  BCF    03,5
0491:  MOVF   36,W
0492:  MOVWF  00
....................   *cLen = cLenExpected; 
0493:  BSF    03,5
0494:  MOVF   33,W
0495:  MOVWF  04
0496:  BCF    03,5
0497:  MOVF   35,W
0498:  MOVWF  00
....................   for ( c=0; c < cLenExpected;c++ )  cData[c] = c485Buf[c]; 
0499:  BSF    03,5
049A:  CLRF   35
049B:  BCF    03,5
049C:  MOVF   35,W
049D:  BSF    03,5
049E:  SUBWF  35,W
049F:  BTFSS  03,0
04A0:  GOTO   4A3
04A1:  BCF    03,5
04A2:  GOTO   4B6
04A3:  BCF    03,5
04A4:  BSF    03,5
04A5:  MOVF   34,W
04A6:  ADDWF  35,W
04A7:  MOVWF  36
04A8:  MOVLW  37
04A9:  ADDWF  35,W
04AA:  MOVWF  04
04AB:  MOVF   00,W
04AC:  MOVWF  37
04AD:  MOVF   36,W
04AE:  MOVWF  04
04AF:  MOVF   37,W
04B0:  MOVWF  00
04B1:  BCF    03,5
04B2:  BSF    03,5
04B3:  INCF   35,F
04B4:  BCF    03,5
04B5:  GOTO   49C
....................  
....................   cData[cLenExpected] = 0x00; // Termninate 
04B6:  BSF    03,5
04B7:  MOVF   34,W
04B8:  BCF    03,5
04B9:  ADDWF  35,W
04BA:  MOVWF  04
04BB:  CLRF   00
04BC:  BCF    0A,3
04BD:  GOTO   5E4
.................... } 
....................  
....................  
.................... /************************************************************************* 
....................  * Example Table Driven CRC16 Routine using 4-bit message chunks 
....................  * 
....................  * By Ashley Roll 
....................  * Digital Nemesis Pty Ltd 
....................  * www.digitalnemesis.com 
....................  * ash@digitalnemesis.com 
....................  * 
....................  * The following is an example of implementing a restricted size CRC16 
....................  * table lookup. No optimisation as been done so the code is clear and 
....................  * easy to understand. 
....................  * 
....................  * Test Vector: "123456789" (character string, no quotes) 
....................  * Generated CRC: 0x29B1 
....................  * 
....................  * Modified for CCS compiler by J.Winpenny 
....................  *************************************************************************/ 
....................  
.................... /* 
....................  * CRC16 Lookup tables (High and Low Byte) for 4 bits per iteration. 
....................  */ 
....................  
.................... const char CRC16_LookupHigh[16] = { 
....................         0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 
....................         0x81, 0x91, 0xA1, 0xB1, 0xC1, 0xD1, 0xE1, 0xF1 
.................... }; 
*
0071:  BCF    0A,0
0072:  BCF    0A,1
0073:  BCF    0A,2
0074:  ADDWF  02,F
0075:  RETLW  00
0076:  RETLW  10
0077:  RETLW  20
0078:  RETLW  30
0079:  RETLW  40
007A:  RETLW  50
007B:  RETLW  60
007C:  RETLW  70
007D:  RETLW  81
007E:  RETLW  91
007F:  RETLW  A1
0080:  RETLW  B1
0081:  RETLW  C1
0082:  RETLW  D1
0083:  RETLW  E1
0084:  RETLW  F1
.................... const char CRC16_LookupLow[16] = { 
....................         0x00, 0x21, 0x42, 0x63, 0x84, 0xA5, 0xC6, 0xE7, 
....................         0x08, 0x29, 0x4A, 0x6B, 0x8C, 0xAD, 0xCE, 0xEF 
.................... }; 
0085:  BCF    0A,0
0086:  BCF    0A,1
0087:  BCF    0A,2
0088:  ADDWF  02,F
0089:  RETLW  00
008A:  RETLW  21
008B:  RETLW  42
008C:  RETLW  63
008D:  RETLW  84
008E:  RETLW  A5
008F:  RETLW  C6
0090:  RETLW  E7
0091:  RETLW  08
0092:  RETLW  29
0093:  RETLW  4A
0094:  RETLW  6B
0095:  RETLW  8C
0096:  RETLW  AD
0097:  RETLW  CE
0098:  RETLW  EF
....................  
....................  
.................... /* 
....................  * Before each message CRC is generated, the CRC register must be 
....................  * initialised by calling this function 
....................  */ 
.................... void CRC16_Init( void ) 
.................... { 
.................... 	// Initialise the CRC to 0xFFFF for the CCITT specification 
.................... 	cCalcCrcHigh = 0xFF; 
*
03C2:  MOVLW  FF
03C3:  MOVWF  79
.................... 	cCalcCrcLow = 0xFF; 
03C4:  MOVWF  7A
.................... } 
....................  
.................... /* 
....................  * Process 4 bits of the message to update the CRC Value. 
....................  * 
....................  * Note that the data must be in the low nibble of val. 
....................  */ 
.................... void CRC16_Update4Bits( char val ) 
.................... { 
.................... 	char	t; 
....................  
.................... 	// Step one, extract the Most significant 4 bits of the CRC register 
.................... 	t = cCalcCrcHigh >> 4; 
*
02A3:  SWAPF  79,W
02A4:  BSF    03,5
02A5:  MOVWF  3A
02A6:  MOVLW  0F
02A7:  ANDWF  3A,F
....................  
.................... 	// XOR in the Message Data into the extracted bits 
.................... 	t = t ^ val; 
02A8:  MOVF   39,W
02A9:  XORWF  3A,F
....................  
.................... 	// Shift the CRC Register left 4 bits 
.................... 	cCalcCrcHigh = (cCalcCrcHigh << 4) | (cCalcCrcLow >> 4); 
02AA:  BCF    03,5
02AB:  SWAPF  79,W
02AC:  BSF    03,5
02AD:  MOVWF  3B
02AE:  MOVLW  F0
02AF:  ANDWF  3B,F
02B0:  BCF    03,5
02B1:  SWAPF  7A,W
02B2:  MOVWF  20
02B3:  MOVLW  0F
02B4:  ANDWF  20,F
02B5:  MOVF   20,W
02B6:  BSF    03,5
02B7:  IORWF  3B,W
02B8:  BCF    03,5
02B9:  MOVWF  79
.................... 	cCalcCrcLow = cCalcCrcLow << 4; 
02BA:  SWAPF  7A,F
02BB:  MOVLW  F0
02BC:  ANDWF  7A,F
....................  
.................... 	// Do the table lookups and XOR the result into the CRC Tables 
.................... 	cCalcCrcHigh = cCalcCrcHigh ^ CRC16_LookupHigh[t]; 
02BD:  BSF    03,5
02BE:  MOVF   3A,W
02BF:  BCF    03,5
02C0:  CALL   071
02C1:  MOVWF  21
02C2:  XORWF  79,F
.................... 	cCalcCrcLow = cCalcCrcLow ^ CRC16_LookupLow[t]; 
02C3:  BSF    03,5
02C4:  MOVF   3A,W
02C5:  BCF    03,5
02C6:  CALL   085
02C7:  MOVWF  21
02C8:  XORWF  7A,F
02C9:  RETLW  00
.................... } 
....................  
.................... /* 
....................  * Process one Message Byte to update the current CRC Value 
....................  */ 
.................... void Rs485UpdateCrc( char cVal ) 
.................... { 
.................... 	CRC16_Update4Bits( cVal >> 4 );		// High nibble first 
02CA:  BSF    03,5
02CB:  SWAPF  37,W
02CC:  MOVWF  38
02CD:  MOVLW  0F
02CE:  ANDWF  38,F
02CF:  MOVF   38,W
02D0:  MOVWF  39
02D1:  BCF    03,5
02D2:  CALL   2A3
.................... 	CRC16_Update4Bits( cVal & 0x0F );	// Low nibble 
02D3:  BSF    03,5
02D4:  MOVF   37,W
02D5:  ANDLW  0F
02D6:  MOVWF  38
02D7:  MOVWF  39
02D8:  BCF    03,5
02D9:  CALL   2A3
02DA:  RETLW  00
.................... } 
....................  
.................... //**************************************************************************** 
.................... // void Rs485SendChar( char c ) 
.................... // 
.................... // Driver level of RS485 protocol 
.................... // Output character on RS485 driver 
.................... // // Include line turn around time 
.................... //**************************************************************************** 
.................... void Rs485SendChar( char c ) 
.................... { 
....................    TXREG = c;                            // Load data to send 
*
0294:  BSF    03,5
0295:  MOVF   37,W
0296:  BCF    03,5
0297:  MOVWF  19
....................    while ( !( TXSTA & TRMT_MASK ));       // Wait for TX Empty 
0298:  BSF    03,5
0299:  MOVF   18,W
029A:  ANDLW  02
029B:  XORLW  00
029C:  BTFSS  03,2
029D:  GOTO   2A0
029E:  BCF    03,5
029F:  GOTO   298
02A0:  BCF    03,5
02A1:  GOTO   2A2
02A2:  RETLW  00
.................... } 
....................  
....................  
.................... //**************************************************************************** 
.................... // char PostValidatePacket(void) 
.................... // 
.................... // Verify the CRC on the last packet received 
.................... // 
.................... // Check if the CRC is correct 
.................... // and return the updated state as the result 
.................... // 
.................... //**************************************************************************** 
.................... char PostValidatePacket(void) 
.................... { 
.................... char c, d; 
....................  
....................   CRC16_Init(); 
....................   Rs485UpdateCrc(PKT_START); 
*
03C5:  MOVLW  02
03C6:  BSF    03,5
03C7:  MOVWF  37
03C8:  BCF    03,5
03C9:  CALL   2CA
....................   Rs485UpdateCrc(cNetAddrHigh); 
03CA:  MOVF   33,W
03CB:  BSF    03,5
03CC:  MOVWF  37
03CD:  BCF    03,5
03CE:  CALL   2CA
....................   Rs485UpdateCrc(cNetAddrLow); 
03CF:  MOVF   34,W
03D0:  BSF    03,5
03D1:  MOVWF  37
03D2:  BCF    03,5
03D3:  CALL   2CA
....................   Rs485UpdateCrc(cLenExpected); 
03D4:  MOVF   35,W
03D5:  BSF    03,5
03D6:  MOVWF  37
03D7:  BCF    03,5
03D8:  CALL   2CA
....................   Rs485UpdateCrc(cCommand); 
03D9:  MOVF   36,W
03DA:  BSF    03,5
03DB:  MOVWF  37
03DC:  BCF    03,5
03DD:  CALL   2CA
....................  
....................   if ( PacketHasPayload() )  // If the packet has a payload, 
03DE:  CALL   106
03DF:  MOVF   21,F
03E0:  BTFSC  03,2
03E1:  GOTO   3FA
....................   {                          // then include the data in the CRC. 
....................      for ( c = 0; c < cLenExpected; c++ ) 
03E2:  BSF    03,5
03E3:  CLRF   34
03E4:  BCF    03,5
03E5:  MOVF   35,W
03E6:  BSF    03,5
03E7:  SUBWF  34,W
03E8:  BTFSS  03,0
03E9:  GOTO   3EC
03EA:  BCF    03,5
03EB:  GOTO   3FA
03EC:  BCF    03,5
....................      { 
....................         d = c485Buf[c]; 
03ED:  MOVLW  37
03EE:  BSF    03,5
03EF:  ADDWF  34,W
03F0:  MOVWF  04
03F1:  MOVF   00,W
03F2:  MOVWF  35
....................         Rs485UpdateCrc( d ); 
03F3:  MOVWF  37
03F4:  BCF    03,5
03F5:  CALL   2CA
....................      } 
03F6:  BSF    03,5
03F7:  INCF   34,F
03F8:  BCF    03,5
03F9:  GOTO   3E5
....................   } 
....................                              // Check if the CRC is correct 
....................                              // and return the updated state as the result 
....................   if ( (cRxCrcHigh == cCalcCrcHigh)&&(cRxCrcLow == cCalcCrcLow) ) 
03FA:  MOVF   79,W
03FB:  SUBWF  77,W
03FC:  BTFSS  03,2
03FD:  GOTO   406
03FE:  GOTO   3FF
03FF:  MOVF   7A,W
0400:  SUBWF  78,W
0401:  BTFSS  03,2
0402:  GOTO   406
....................   { 
....................      cRS485State = PKT_VALID; 
0403:  MOVLW  09
0404:  MOVWF  31
....................   } 
....................   else 
0405:  GOTO   438
....................   { 
....................      cError = BAD_CRC; 
0406:  MOVLW  02
0407:  MOVWF  7C
....................      cRS485State = PKT_INVALID; 
0408:  MOVLW  FF
0409:  MOVWF  31
....................      ClearLine2(); 
040A:  CALL   27D
....................      BinToHexAscii(cRxCrcHigh ); 
040B:  MOVF   77,W
040C:  BSF    03,5
040D:  MOVWF  36
040E:  BCF    03,5
040F:  CALL   379
....................      BinToHexAscii(cRxCrcLow ); 
0410:  MOVF   78,W
0411:  BSF    03,5
0412:  MOVWF  36
0413:  BCF    03,5
0414:  CALL   379
....................      LcdWrite(' '); 
0415:  MOVLW  20
0416:  BSF    03,5
0417:  MOVWF  3A
0418:  BCF    03,5
0419:  CALL   1C9
....................      BinToHexAscii(cCalcCrcHigh); 
041A:  MOVF   79,W
041B:  BSF    03,5
041C:  MOVWF  36
041D:  BCF    03,5
041E:  CALL   379
....................      BinToHexAscii(cCalcCrcHigh); 
041F:  MOVF   79,W
0420:  BSF    03,5
0421:  MOVWF  36
0422:  BCF    03,5
0423:  CALL   379
....................      delay_ms(255); 
0424:  MOVLW  FF
0425:  BSF    03,5
0426:  MOVWF  3C
0427:  BCF    03,5
0428:  CALL   1A0
....................      delay_ms(255); 
0429:  MOVLW  FF
042A:  BSF    03,5
042B:  MOVWF  3C
042C:  BCF    03,5
042D:  CALL   1A0
....................      delay_ms(255); 
042E:  MOVLW  FF
042F:  BSF    03,5
0430:  MOVWF  3C
0431:  BCF    03,5
0432:  CALL   1A0
....................      delay_ms(255); 
0433:  MOVLW  FF
0434:  BSF    03,5
0435:  MOVWF  3C
0436:  BCF    03,5
0437:  CALL   1A0
....................   } 
....................  
....................   return cRS485State; 
0438:  MOVF   31,W
0439:  MOVWF  21
.................... } 
....................  
.................... //**************************************************************************** 
.................... // char GetPacketCmdType(void) 
.................... // 
.................... // Check packet command type 
.................... // Return TRUE if packet has a data payload. 
.................... // 
.................... //**************************************************************************** 
.................... char PacketHasPayload(void) 
.................... { 
....................   if ( cCommand == SENSOR_GET_DATA ) return TRUE; 
*
0106:  MOVF   36,W
0107:  SUBLW  A4
0108:  BTFSS  03,2
0109:  GOTO   10E
010A:  MOVLW  01
010B:  MOVWF  21
010C:  GOTO   111
....................   else return FALSE; 
010D:  GOTO   111
010E:  MOVLW  00
010F:  MOVWF  21
0110:  GOTO   111
0111:  RETLW  00
.................... } 
....................  
.................... //**************************************************************************** 
.................... // void BinToHexAscii( char c ) 
.................... // 
.................... // Contributed by: Nick De Smith 
.................... // 
.................... //**************************************************************************** 
.................... void BinToHexAscii( char c ) 
.................... { 
....................  const char hexMap[17] = "0123456789ABCDEF"; 
*
0099:  BCF    0A,0
009A:  BCF    0A,1
009B:  BCF    0A,2
009C:  ADDWF  02,F
009D:  RETLW  30
009E:  RETLW  31
009F:  RETLW  32
00A0:  RETLW  33
00A1:  RETLW  34
00A2:  RETLW  35
00A3:  RETLW  36
00A4:  RETLW  37
00A5:  RETLW  38
00A6:  RETLW  39
00A7:  RETLW  41
00A8:  RETLW  42
00A9:  RETLW  43
00AA:  RETLW  44
00AB:  RETLW  45
00AC:  RETLW  46
00AD:  RETLW  00
....................  
....................     LcdWrite( hexMap[(c >> 4) & 0xF] ); 
*
0379:  BSF    03,5
037A:  SWAPF  36,W
037B:  BCF    03,5
037C:  MOVWF  20
037D:  MOVLW  0F
037E:  ANDWF  20,F
037F:  MOVF   20,W
0380:  ANDLW  0F
0381:  CALL   099
0382:  BSF    03,5
0383:  MOVWF  39
0384:  MOVWF  3A
0385:  BCF    03,5
0386:  CALL   1C9
....................     LcdWrite( hexMap[(c & 0xF)] ); 
0387:  BSF    03,5
0388:  MOVF   36,W
0389:  ANDLW  0F
038A:  BCF    03,5
038B:  CALL   099
038C:  BSF    03,5
038D:  MOVWF  38
038E:  MOVWF  3A
038F:  BCF    03,5
0390:  CALL   1C9
0391:  RETLW  00
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... 
.................... //#include <lcd2.c>   // LCD routine 
.................... #include <lcd873b.c>  // Keypad example LCD routine 
....................  /***************************************************************************/ 
.................... /*  Lcd.c       LCD interface routines                                     */ 
.................... /*  Version :   2.1. for PIC16F87x                                         */ 
.................... /*                                                                         */ 
.................... /*  J. Winpenny  1/8/2000                                                  */ 
.................... /*                                                                         */ 
.................... /*                                                                         */ 
.................... /*  Mode : HD44780 type LCD displays                                       */ 
.................... /*                                                                         */ 
.................... /*                                                                         */ 
.................... /* Notes : Updated version                                                 */ 
.................... /*         to allow greater adaptability to different displays             */ 
.................... /*                                                                         */ 
.................... /***************************************************************************/ 
....................  
.................... #include "lcd873b.h" 
....................  void LCDSetup(void); 
.................... void FunctionMode(void); 
.................... void DataMode(void); 
.................... void Write_8_Bit(char dh ); 
.................... void LcdWrite(char dl ); 
.................... void Delaylcd(void); 
.................... void Clear(void); 
.................... void SetPos(char Pos); 
.................... void Line_1(void); 
.................... void Line_2(void); 
.................... void ClearLine1(void); 
.................... void ClearLine2(void); 
....................  
....................  
....................  
....................  
.................... /************************************************************/ 
.................... /* LCD Commands ( Refer to LCD Data Sheet )                 */ 
.................... /* Standard command should work with most common devices    */ 
.................... /************************************************************/ 
....................  
.................... #define clear_lcd         0x01 /* Clear Display                       */ 
.................... #define return_home       0x02 /* Cursor to Home position             */ 
.................... #define entry_mode        0x06 /* Normal entry mode                   */ 
.................... #define entry_mode_shift  0x07 /* - with shift                        */ 
.................... #define system_set_8_bit  0x38 
.................... /* 8 bit data mode 2 line ( 5x7 font ) */ 
.................... #define system_set_4_bit  0x28 
.................... /* 4 bit data mode 2 line ( 5x7 font ) */ 
.................... #define display_on        0x0c /* Switch ON Display                   */ 
.................... #define display_off       0x08 /* Cursor plus blink                   */ 
.................... #define set_dd_line1      0x80 /* Line 1 position 1                   */ 
.................... #define set_dd_line2      0xC0 /* Line 2 position 1                   */ 
.................... #define set_dd_ram        0x80 /* Line 1 position 1                   */ 
.................... #define write_data        0x00 /* With rs = 1                         */ 
.................... #define cursor_on         0x0E /* Switch Cursor ON                    */ 
.................... #define cursor_off        0x0C /* Switch Cursor OFF                   */ 
....................  
.................... 
....................  
.................... /* Definitions for the LCD interface */ 
....................  
.................... #define LCD_SEL 3 /* Port A bit 3 ( Enables LCD ) */ 
.................... #define LCD_WR  2 /* Port A bit 2 ( Logic 0 = Write ) */ 
.................... #define LCD_RS  0 /* Port A bit 1 ( Register select ) */ 
.................... #define LCD_DATA PORTB 
.................... #define LCD_CONTROL PORTA 
....................  
....................  
.................... #define BUSY_BIT 7 
.................... #define BUSY_MASK 0x80 
....................  
.................... #define LCD_DATA_4 4   /* LCD BIT 0 */ 
.................... #define LCD_DATA_5 5   /* LCD BIT 1 */ 
.................... #define LCD_DATA_6 6   /* LCD BIT 2 */ 
.................... #define LCD_DATA_7 7   /* LCD BIT 3 */ 
....................  
....................  
.................... char ModeFlags; 
.................... char LCD_gp; 
....................  
....................  
.................... /***********************************/ 
.................... /* Setup the lcd device            */ 
.................... /***********************************/ 
.................... void LCDSetup(void) 
.................... { 
....................  /* Reset the LCD */ 
....................  
....................    ModeFlags = 0;           /* Default to Function Mode */ 
*
0211:  BSF    03,5
0212:  CLRF   22
....................  
....................  
....................    Write_8_Bit( system_set_4_bit ); /* This sequence resets the LCD */ 
0213:  MOVLW  28
0214:  MOVWF  32
0215:  BCF    03,5
0216:  CALL   1BB
....................    delay_ms(5); 
0217:  MOVLW  05
0218:  BSF    03,5
0219:  MOVWF  3C
021A:  BCF    03,5
021B:  CALL   1A0
....................    Write_8_Bit( system_set_4_bit ); 
021C:  MOVLW  28
021D:  BSF    03,5
021E:  MOVWF  32
021F:  BCF    03,5
0220:  CALL   1BB
....................    delay_ms(1); 
0221:  MOVLW  01
0222:  BSF    03,5
0223:  MOVWF  3C
0224:  BCF    03,5
0225:  CALL   1A0
....................    Write_8_Bit( system_set_4_bit ); 
0226:  MOVLW  28
0227:  BSF    03,5
0228:  MOVWF  32
0229:  BCF    03,5
022A:  CALL   1BB
....................    delay_ms(1); 
022B:  MOVLW  01
022C:  BSF    03,5
022D:  MOVWF  3C
022E:  BCF    03,5
022F:  CALL   1A0
....................    LcdWrite( system_set_4_bit ); 
0230:  MOVLW  28
0231:  BSF    03,5
0232:  MOVWF  3A
0233:  BCF    03,5
0234:  CALL   1C9
....................  
....................    LcdWrite( display_on ); 
0235:  MOVLW  0C
0236:  BSF    03,5
0237:  MOVWF  3A
0238:  BCF    03,5
0239:  CALL   1C9
....................    LcdWrite( clear_lcd ); 
023A:  MOVLW  01
023B:  BSF    03,5
023C:  MOVWF  3A
023D:  BCF    03,5
023E:  CALL   1C9
....................    LcdWrite( entry_mode ); 
023F:  MOVLW  06
0240:  BSF    03,5
0241:  MOVWF  3A
0242:  BCF    03,5
0243:  CALL   1C9
....................    LcdWrite( set_dd_ram ); 
0244:  MOVLW  80
0245:  BSF    03,5
0246:  MOVWF  3A
0247:  BCF    03,5
0248:  CALL   1C9
....................    ModeFlags = 1; /* Data Mode */ 
0249:  MOVLW  01
024A:  BSF    03,5
024B:  MOVWF  22
024C:  BCF    03,5
....................  
.................... } 
....................  
....................  
....................  
.................... /***********************************/ 
.................... /* Put LCD in Function Mode        */ 
.................... /***********************************/ 
.................... void FunctionMode(void) 
.................... { 
....................    BIT_CLEAR( ModeFlags, 0 ); /* Save Mode */ 
*
026B:  BSF    03,5
026C:  BCF    22,0
....................    #asm BCF LCD_CONTROL, LCD_RS #endasm 
....................    Delaylcd(); 
026D:  BCF    03,5
026E:  CALL   1B5
026F:  RETLW  00
.................... } 
....................  
.................... /***********************************/ 
.................... /* Put LCD in Data Mode            */ 
.................... /***********************************/ 
....................  
.................... void DataMode(void) 
.................... { 
....................    BIT_SET( ModeFlags, 0 ); /* Save Mode */ 
0270:  BSF    03,5
0271:  BSF    22,0
....................    #asm BSF LCD_CONTROL, LCD_RS #endasm 
....................    Delaylcd(); 
0272:  BCF    03,5
0273:  CALL   1B5
0274:  RETLW  00
.................... } 
....................  
.................... /***********************************/ 
.................... /* Write a single byte to the LCD  */ 
.................... /* 8 Bit Mode                      */ 
.................... /***********************************/ 
.................... void Write_8_Bit( char dh ) 
.................... { 
....................    #asm BCF LCD_CONTROL, LCD_WR #endasm 
....................    #asm BCF LCD_CONTROL, LCD_RS #endasm 
....................    #asm BCF LCD_CONTROL, LCD_SEL #endasm 
....................  
....................    //LCD_CONTROL = 0; 
....................  
....................    delay_ms(1); 
*
01BB:  MOVLW  01
01BC:  BSF    03,5
01BD:  MOVWF  3C
01BE:  BCF    03,5
01BF:  CALL   1A0
....................    LCD_DATA = dh;                          /* Setup data    */ 
01C0:  BSF    03,5
01C1:  MOVF   32,W
01C2:  BCF    03,5
01C3:  MOVWF  06
....................    BIT_SET( LCD_CONTROL, LCD_SEL );        /* Select LCD    */ 
01C4:  BSF    05,3
....................    Delaylcd(); 
01C5:  CALL   1B5
....................    BIT_CLEAR( LCD_CONTROL, LCD_SEL );     /* de-select LCD */ 
01C6:  BCF    05,3
....................    Delaylcd(); 
01C7:  CALL   1B5
01C8:  RETLW  00
....................     
.................... } 
....................  
....................  
.................... /***********************************/ 
.................... /* Write a single byte to the LCD  */ 
.................... /* 4 Bit Mode                      */ 
.................... /***********************************/ 
.................... void LcdWrite(char dl ) 
.................... { 
....................  
.................... char e; 
....................  
....................    e = dl;                           /* Save lower 4 bits */ 
01C9:  BSF    03,5
01CA:  MOVF   3A,W
01CB:  MOVWF  3B
....................  
.................... /*********************************** Output Upper 8 bits ******************************/ 
....................  
....................    BIT_CLEAR( LCD_CONTROL, LCD_WR );       /* Write mode */ 
01CC:  BCF    03,5
01CD:  BCF    05,2
....................  
....................    if ( ( ModeFlags & 0x01 ) == 0 ) 
01CE:  BSF    03,5
01CF:  MOVF   22,W
01D0:  ANDLW  01
01D1:  XORLW  00
01D2:  BTFSC  03,2
01D3:  GOTO   1D6
01D4:  BCF    03,5
01D5:  GOTO   1D9
01D6:  BCF    03,5
....................       BIT_CLEAR( LCD_CONTROL, LCD_RS );    /* Function mode */ 
01D7:  BCF    05,0
....................    else 
01D8:  GOTO   1DA
....................       BIT_SET( LCD_CONTROL, LCD_RS );      /* Data mode */ 
01D9:  BSF    05,0
....................  
....................    BIT_CLEAR( LCD_CONTROL, LCD_SEL); 
01DA:  BCF    05,3
....................    LCD_DATA = dl;                           /* Setup data    */ 
01DB:  BSF    03,5
01DC:  MOVF   3A,W
01DD:  BCF    03,5
01DE:  MOVWF  06
....................  
....................    BIT_SET( LCD_CONTROL, LCD_SEL);         /* Select LCD    */ 
01DF:  BSF    05,3
....................    Delaylcd(); 
01E0:  CALL   1B5
....................    BIT_CLEAR( LCD_CONTROL, LCD_SEL );      /* de-select LCD */ 
01E1:  BCF    05,3
....................  
....................  
....................    dl = e;                                  /* Restore lower 4 bits */ 
01E2:  BSF    03,5
01E3:  MOVF   3B,W
01E4:  MOVWF  3A
....................    dl <<= 4; 
01E5:  SWAPF  3A,F
01E6:  MOVLW  F0
01E7:  ANDWF  3A,F
....................  
.................... /*********************************** Output Lower 8 bits ******************************/ 
....................  
....................    BIT_CLEAR( LCD_CONTROL, LCD_WR );       /* Write mode    */ 
01E8:  BCF    03,5
01E9:  BCF    05,2
....................  
....................    if ( ( ModeFlags & 0x01 ) == 0 ) 
01EA:  BSF    03,5
01EB:  MOVF   22,W
01EC:  ANDLW  01
01ED:  XORLW  00
01EE:  BTFSC  03,2
01EF:  GOTO   1F2
01F0:  BCF    03,5
01F1:  GOTO   1F5
01F2:  BCF    03,5
....................       BIT_CLEAR( LCD_CONTROL, LCD_RS );    /* Function mode */ 
01F3:  BCF    05,0
....................    else 
01F4:  GOTO   1F6
....................       BIT_SET( LCD_CONTROL, LCD_RS );      /* Data mode */ 
01F5:  BSF    05,0
....................  
....................    BIT_CLEAR( LCD_CONTROL, LCD_SEL); 
01F6:  BCF    05,3
....................    LCD_DATA = dl;                           /* Setup data    */ 
01F7:  BSF    03,5
01F8:  MOVF   3A,W
01F9:  BCF    03,5
01FA:  MOVWF  06
....................  
....................    BIT_SET( LCD_CONTROL, LCD_SEL);         /* Select LCD    */ 
01FB:  BSF    05,3
....................    Delaylcd(); 
01FC:  CALL   1B5
....................    BIT_CLEAR( LCD_CONTROL, LCD_SEL );      /* de-select LCD */ 
01FD:  BCF    05,3
....................    Delaylcd(); 
01FE:  CALL   1B5
01FF:  RETLW  00
.................... } 
....................  
.................... /***********************************/ 
.................... /* LCD timing delay                */ 
.................... /* Adjust for your LCD Display     */ 
.................... /***********************************/ 
.................... void Delaylcd(void) 
.................... { 
....................    delay_ms(2); 
*
01B5:  MOVLW  02
01B6:  BSF    03,5
01B7:  MOVWF  3C
01B8:  BCF    03,5
01B9:  CALL   1A0
01BA:  RETLW  00
.................... } 
....................  
.................... /***********************************/ 
.................... /* Clear LCD Screen                */ 
.................... /***********************************/ 
.................... void Clear(void) 
.................... { 
....................  
....................    FunctionMode(); 
....................    LcdWrite(clear_lcd); 
....................    DataMode(); 
....................  
.................... } 
....................  
.................... /***********************************/ 
.................... /* Set the cursor position         */ 
.................... /***********************************/ 
.................... void SetPos(char Pos) 
.................... { 
....................  
....................    FunctionMode(); 
....................    LcdWrite( Pos ); 
....................    DataMode(); 
....................  
.................... } 
....................  
.................... /***********************************/ 
.................... /* Set Position to line 1          */ 
.................... /***********************************/ 
.................... void Line1(void) 
.................... { 
....................    FunctionMode(); 
*
04BE:  CALL   26B
....................    LcdWrite( set_dd_line1 ); 
04BF:  MOVLW  80
04C0:  BSF    03,5
04C1:  MOVWF  3A
04C2:  BCF    03,5
04C3:  CALL   1C9
....................    DataMode(); 
04C4:  CALL   270
04C5:  RETLW  00
.................... } 
....................  
.................... /***********************************/ 
.................... /* Set Position to line 2          */ 
.................... /***********************************/ 
.................... void Line2(void) 
.................... { 
....................    FunctionMode(); 
*
0275:  CALL   26B
....................    LcdWrite( set_dd_line2 ); 
0276:  MOVLW  C0
0277:  BSF    03,5
0278:  MOVWF  3A
0279:  BCF    03,5
027A:  CALL   1C9
....................    DataMode(); 
027B:  CALL   270
027C:  RETLW  00
.................... } 
....................  
.................... /*******************************************/ 
.................... /* Clear Line 1                            */ 
.................... /*******************************************/ 
.................... void ClearLine1(void) 
.................... { 
....................  
....................    Line1(); 
*
062C:  CALL   4BE
....................  
....................    for( LCD_gp = 0; LCD_gp < 16; LCD_gp++ ) 
062D:  BSF    03,5
062E:  CLRF   23
062F:  BCF    03,5
0630:  BSF    03,5
0631:  MOVF   23,W
0632:  SUBLW  0F
0633:  BTFSC  03,0
0634:  GOTO   637
0635:  BCF    03,5
0636:  GOTO   641
0637:  BCF    03,5
....................       { 
....................           LcdWrite(' '); 
0638:  MOVLW  20
0639:  BSF    03,5
063A:  MOVWF  3A
063B:  BCF    03,5
063C:  CALL   1C9
....................       } 
063D:  BSF    03,5
063E:  INCF   23,F
063F:  BCF    03,5
0640:  GOTO   630
....................  
....................    Line1(); 
0641:  CALL   4BE
.................... } 
....................  
.................... /*******************************************/ 
.................... /* Clear Line 2                            */ 
.................... /*******************************************/ 
.................... void ClearLine2(void) 
.................... { 
....................  
....................   Line2(); 
*
027D:  CALL   275
....................  
....................   for( LCD_gp = 0; LCD_gp < 16; LCD_gp++ ) 
027E:  BSF    03,5
027F:  CLRF   23
0280:  BCF    03,5
0281:  BSF    03,5
0282:  MOVF   23,W
0283:  SUBLW  0F
0284:  BTFSC  03,0
0285:  GOTO   288
0286:  BCF    03,5
0287:  GOTO   292
0288:  BCF    03,5
....................      { 
....................          LcdWrite(' '); 
0289:  MOVLW  20
028A:  BSF    03,5
028B:  MOVWF  3A
028C:  BCF    03,5
028D:  CALL   1C9
....................      } 
028E:  BSF    03,5
028F:  INCF   23,F
0290:  BCF    03,5
0291:  GOTO   281
....................  
....................   Line2(); 
0292:  CALL   275
0293:  RETLW  00
.................... } 
....................  
.................... 
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... char cTest[10]; 
....................  
.................... //************************************************** 
.................... // Timer Interrupt service routine 
.................... //************************************************** 
.................... #INT_RTCC 
.................... clock_isr() 
.................... { 
....................      TMR0 = TMR0_RELOAD;        // Reload PICs timer 
*
00FE:  MOVLW  FF
00FF:  BSF    03,6
0100:  MOVWF  01
....................      BIT_CLEAR( INTCON, T0IF ); // Clear interrupt flag 
0101:  BCF    03,6
0102:  BCF    0B,2
.................... } 
....................  
.................... //************************************************** 
.................... // USART interrupt service routine 
.................... //************************************************** 
0103:  BCF    0B,2
0104:  BCF    0A,3
0105:  GOTO   02E
.................... #INT_RDA 
.................... void UsartInterrupt(void) 
.................... { 
....................  
....................     while ( BIT_TEST( PIR1, RCIF )  )              // If USART RX Interrupt 
*
0185:  BTFSS  0C,5
0186:  GOTO   19D
....................     { 
....................  
....................          TMR0 = TMR0_RELOAD; 
0187:  MOVLW  FF
0188:  BSF    03,6
0189:  MOVWF  01
....................  
....................          cRs485RxChar = RCREG; 
018A:  BCF    03,6
018B:  MOVF   1A,W
018C:  MOVWF  30
....................  
....................          if ( !( RCSTA & 6 ) )                 // Then if no errors 
018D:  MOVF   18,W
018E:  ANDLW  06
018F:  XORLW  00
0190:  BTFSS  03,2
0191:  GOTO   195
....................          {                                     // Process received character 
....................              Rs485Decode();                    // Decode RS485 network trafic 
0192:  GOTO   112
....................              bit_set( RCSTA, CREN );           // Enable receiver. 
0193:  BSF    18,4
....................          } 
....................          else 
0194:  GOTO   19B
....................          { 
....................              bit_clear( RCSTA, CREN );         // Clear any errors 
0195:  BCF    18,4
....................              cRs485RxChar = RCREG; 
0196:  MOVF   1A,W
0197:  MOVWF  30
....................              cRs485RxChar = RCREG; 
0198:  MOVF   1A,W
0199:  MOVWF  30
....................              bit_set( RCSTA, CREN );           // Enable receiver. 
019A:  BSF    18,4
....................          } 
....................  
....................         bit_clear( PIR1, RCIF ); 
019B:  BCF    0C,5
....................  
....................     } 
019C:  GOTO   185
....................  
019D:  BCF    0C,5
019E:  BCF    0A,3
019F:  GOTO   02E
.................... } 
....................  
.................... void main(void) 
.................... { 
.................... char cPacketReady; 
.................... char cLenOfData; 
.................... char cCmd, c; 
*
04C6:  CLRF   04
04C7:  MOVLW  1F
04C8:  ANDWF  03,F
04C9:  MOVLW  9F
04CA:  MOVWF  04
04CB:  MOVLW  07
04CC:  MOVWF  00
04CD:  CLRF   2E
04CE:  CLRF   2F
04CF:  CLRF   30
04D0:  CLRF   31
04D1:  CLRF   32
04D2:  CLRF   33
04D3:  CLRF   34
04D4:  CLRF   35
04D5:  CLRF   36
04D6:  CLRF   37
04D7:  CLRF   38
04D8:  CLRF   39
04D9:  CLRF   3A
04DA:  CLRF   3B
04DB:  CLRF   3C
04DC:  CLRF   3D
04DD:  CLRF   3E
04DE:  CLRF   3F
04DF:  CLRF   40
04E0:  CLRF   41
04E1:  CLRF   42
04E2:  CLRF   43
04E3:  CLRF   44
04E4:  CLRF   45
04E5:  CLRF   46
04E6:  CLRF   47
04E7:  CLRF   48
04E8:  CLRF   49
04E9:  CLRF   4A
04EA:  CLRF   4B
04EB:  CLRF   4C
04EC:  CLRF   4D
04ED:  CLRF   4E
04EE:  CLRF   4F
04EF:  CLRF   50
04F0:  CLRF   51
04F1:  CLRF   52
04F2:  CLRF   53
04F3:  CLRF   54
04F4:  CLRF   55
04F5:  CLRF   56
04F6:  CLRF   57
04F7:  CLRF   58
04F8:  CLRF   59
04F9:  CLRF   5A
04FA:  CLRF   5B
04FB:  CLRF   5C
04FC:  CLRF   5D
04FD:  CLRF   5E
04FE:  CLRF   5F
04FF:  CLRF   60
0500:  CLRF   61
0501:  CLRF   62
0502:  CLRF   63
0503:  CLRF   64
0504:  CLRF   65
0505:  CLRF   66
0506:  CLRF   67
0507:  CLRF   68
0508:  CLRF   69
0509:  CLRF   6A
050A:  CLRF   6B
050B:  CLRF   6C
050C:  CLRF   6D
050D:  CLRF   6E
050E:  CLRF   6F
050F:  CLRF   70
0510:  CLRF   71
0511:  CLRF   72
0512:  CLRF   73
0513:  CLRF   74
0514:  CLRF   75
0515:  CLRF   76
0516:  CLRF   77
0517:  CLRF   78
0518:  CLRF   79
0519:  CLRF   7A
051A:  CLRF   7B
051B:  CLRF   7C
051C:  CLRF   7D
051D:  CLRF   7E
051E:  CLRF   7F
051F:  BSF    03,5
0520:  CLRF   20
0521:  CLRF   21
....................  
....................    Setup(); 
0522:  BCF    03,5
0523:  GOTO   200
....................    BIT_CLEAR( INTCON, T0IE ); // Timer interrupts off 
0524:  BCF    0B,5
....................  
.................... #ifndef MASTER 
....................    LcdWrite("Waiting........"); 
.................... #else 
....................    LcdWrite("Sending message"); 
*
00AE:  BCF    0A,0
00AF:  BCF    0A,1
00B0:  BCF    0A,2
00B1:  ADDWF  02,F
00B2:  RETLW  53
00B3:  RETLW  65
00B4:  RETLW  6E
00B5:  RETLW  64
00B6:  RETLW  69
00B7:  RETLW  6E
00B8:  RETLW  67
00B9:  RETLW  20
00BA:  RETLW  6D
00BB:  RETLW  65
00BC:  RETLW  73
00BD:  RETLW  73
00BE:  RETLW  61
00BF:  RETLW  67
00C0:  RETLW  65
00C1:  RETLW  00
*
0525:  BSF    03,5
0526:  CLRF   32
0527:  BCF    03,5
0528:  BSF    03,5
0529:  MOVF   32,W
052A:  BCF    03,5
052B:  CALL   0AE
052C:  IORLW  00
052D:  BTFSC  03,2
052E:  GOTO   535
052F:  BSF    03,5
0530:  INCF   32,F
0531:  MOVWF  3A
0532:  BCF    03,5
0533:  CALL   1C9
0534:  GOTO   528
.................... #endif 
....................  
....................      // Just setup the network address 
....................      //write_eeprom( NET_ADDRESS_HIGH, 0x10 ); 
....................      //write_eeprom( NET_ADDRESS_LOW, 0x10 ); 
....................      //cOurAddrHigh = read_eeprom( NET_ADDRESS_HIGH  ); 
....................      //cOurAddressLow = read_eeprom( NET_ADDRESS_LOW ); 
....................  
....................       while ( 1 ) 
....................       { 
....................  
....................         cOurAddrHigh = 0x10; 
0535:  MOVLW  10
0536:  MOVWF  2E
....................         cOurAddrLow = 0x10; 
0537:  MOVWF  2F
....................         Rs485Initialise( cOurAddrHigh,cOurAddrLow ); 
0538:  MOVF   2E,W
0539:  BSF    03,5
053A:  MOVWF  32
053B:  BCF    03,5
053C:  MOVF   2F,W
053D:  BSF    03,5
053E:  MOVWF  33
053F:  BCF    03,5
0540:  CALL   25D
....................  
....................         #ifdef MASTER 
....................         cTest[0] = 'H'; 
0541:  MOVLW  48
0542:  BSF    03,5
0543:  MOVWF  24
....................         cTest[1] = 'e'; 
0544:  MOVLW  65
0545:  MOVWF  25
....................         cTest[2] = 'l'; 
0546:  MOVLW  6C
0547:  MOVWF  26
....................         cTest[3] = 'l'; 
0548:  MOVWF  27
....................         cTest[4] = 'o'; 
0549:  MOVLW  6F
054A:  MOVWF  28
....................         cTest[5] = 0; 
054B:  CLRF   29
....................  
....................         ClearLine2(); 
054C:  BCF    03,5
054D:  CALL   27D
....................         LcdWrite("GET DATA PKT"); 
*
00C2:  BCF    0A,0
00C3:  BCF    0A,1
00C4:  BCF    0A,2
00C5:  ADDWF  02,F
00C6:  RETLW  47
00C7:  RETLW  45
00C8:  RETLW  54
00C9:  RETLW  20
00CA:  RETLW  44
00CB:  RETLW  41
00CC:  RETLW  54
00CD:  RETLW  41
00CE:  RETLW  20
00CF:  RETLW  50
00D0:  RETLW  4B
00D1:  RETLW  54
00D2:  RETLW  00
*
054E:  BSF    03,5
054F:  CLRF   32
0550:  BCF    03,5
0551:  BSF    03,5
0552:  MOVF   32,W
0553:  BCF    03,5
0554:  CALL   0C2
0555:  IORLW  00
0556:  BTFSC  03,2
0557:  GOTO   55E
0558:  BSF    03,5
0559:  INCF   32,F
055A:  MOVWF  3A
055B:  BCF    03,5
055C:  CALL   1C9
055D:  GOTO   551
....................         Rs485SendPacket( SENSOR_GET_DATA, 5, &cTest[0] ); 
055E:  MOVLW  A4
055F:  BSF    03,5
0560:  MOVWF  32
0561:  MOVLW  05
0562:  MOVWF  33
0563:  MOVLW  A4
0564:  MOVWF  34
0565:  BCF    03,5
0566:  CALL   2DB
....................         delay_ms(250); 
0567:  MOVLW  FA
0568:  BSF    03,5
0569:  MOVWF  3C
056A:  BCF    03,5
056B:  CALL   1A0
....................         delay_ms(250); 
056C:  MOVLW  FA
056D:  BSF    03,5
056E:  MOVWF  3C
056F:  BCF    03,5
0570:  CALL   1A0
....................         delay_ms(250); 
0571:  MOVLW  FA
0572:  BSF    03,5
0573:  MOVWF  3C
0574:  BCF    03,5
0575:  CALL   1A0
....................         delay_ms(250); 
0576:  MOVLW  FA
0577:  BSF    03,5
0578:  MOVWF  3C
0579:  BCF    03,5
057A:  CALL   1A0
....................         ClearLine2(); 
057B:  CALL   27D
....................         LcdWrite("POLL PKT"); 
*
00D3:  BCF    0A,0
00D4:  BCF    0A,1
00D5:  BCF    0A,2
00D6:  ADDWF  02,F
00D7:  RETLW  50
00D8:  RETLW  4F
00D9:  RETLW  4C
00DA:  RETLW  4C
00DB:  RETLW  20
00DC:  RETLW  50
00DD:  RETLW  4B
00DE:  RETLW  54
00DF:  RETLW  00
*
057C:  BSF    03,5
057D:  CLRF   32
057E:  BCF    03,5
057F:  BSF    03,5
0580:  MOVF   32,W
0581:  BCF    03,5
0582:  CALL   0D3
0583:  IORLW  00
0584:  BTFSC  03,2
0585:  GOTO   58C
0586:  BSF    03,5
0587:  INCF   32,F
0588:  MOVWF  3A
0589:  BCF    03,5
058A:  CALL   1C9
058B:  GOTO   57F
....................         Rs485SendPacket( SENSOR_POLL_CMD, 0, &cTest[0] ); 
058C:  MOVLW  A1
058D:  BSF    03,5
058E:  MOVWF  32
058F:  CLRF   33
0590:  MOVLW  A4
0591:  MOVWF  34
0592:  BCF    03,5
0593:  CALL   2DB
....................         delay_ms(250); 
0594:  MOVLW  FA
0595:  BSF    03,5
0596:  MOVWF  3C
0597:  BCF    03,5
0598:  CALL   1A0
....................         delay_ms(250); 
0599:  MOVLW  FA
059A:  BSF    03,5
059B:  MOVWF  3C
059C:  BCF    03,5
059D:  CALL   1A0
....................         delay_ms(250); 
059E:  MOVLW  FA
059F:  BSF    03,5
05A0:  MOVWF  3C
05A1:  BCF    03,5
05A2:  CALL   1A0
....................         delay_ms(250); 
05A3:  MOVLW  FA
05A4:  BSF    03,5
05A5:  MOVWF  3C
05A6:  BCF    03,5
05A7:  CALL   1A0
....................  
....................         cOurAddrHigh = 0x10; 
05A8:  MOVLW  10
05A9:  MOVWF  2E
....................         cOurAddrLow = 0x18; 
05AA:  MOVLW  18
05AB:  MOVWF  2F
....................         // Send a packet to another node 
....................         Rs485Initialise( cOurAddrHigh,cOurAddrLow ); 
05AC:  MOVF   2E,W
05AD:  BSF    03,5
05AE:  MOVWF  32
05AF:  BCF    03,5
05B0:  MOVF   2F,W
05B1:  BSF    03,5
05B2:  MOVWF  33
05B3:  BCF    03,5
05B4:  CALL   25D
....................  
....................         Rs485SendPacket( SENSOR_POLL_CMD, 0, &cTest[0] ); 
05B5:  MOVLW  A1
05B6:  BSF    03,5
05B7:  MOVWF  32
05B8:  CLRF   33
05B9:  MOVLW  A4
05BA:  MOVWF  34
05BB:  BCF    03,5
05BC:  CALL   2DB
....................         delay_ms(250); 
05BD:  MOVLW  FA
05BE:  BSF    03,5
05BF:  MOVWF  3C
05C0:  BCF    03,5
05C1:  CALL   1A0
....................         delay_ms(250); 
05C2:  MOVLW  FA
05C3:  BSF    03,5
05C4:  MOVWF  3C
05C5:  BCF    03,5
05C6:  CALL   1A0
....................         delay_ms(250); 
05C7:  MOVLW  FA
05C8:  BSF    03,5
05C9:  MOVWF  3C
05CA:  BCF    03,5
05CB:  CALL   1A0
....................         delay_ms(250); 
05CC:  MOVLW  FA
05CD:  BSF    03,5
05CE:  MOVWF  3C
05CF:  BCF    03,5
05D0:  CALL   1A0
....................  
....................         #endif 
....................  
....................         cPacketReady = Rs485Process(); 
05D1:  GOTO   392
05D2:  MOVF   21,W
05D3:  BSF    03,5
05D4:  MOVWF  2E
....................  
....................         if ( cPacketReady ) 
05D5:  MOVF   2E,F
05D6:  BTFSS  03,2
05D7:  GOTO   5DA
05D8:  BCF    03,5
05D9:  GOTO   652
05DA:  BCF    03,5
....................         { 
....................            Rs485GetPacket( &cCmd, &cLenOfData, &cTest[0] ); 
05DB:  MOVLW  B0
05DC:  BSF    03,5
05DD:  MOVWF  32
05DE:  MOVLW  AF
05DF:  MOVWF  33
05E0:  MOVLW  A4
05E1:  MOVWF  34
05E2:  BCF    03,5
05E3:  GOTO   48D
....................  
....................            ClearLine2(); 
05E4:  CALL   27D
....................            LcdWrite( "CMD: " ); 
*
00E0:  BCF    0A,0
00E1:  BCF    0A,1
00E2:  BCF    0A,2
00E3:  ADDWF  02,F
00E4:  RETLW  43
00E5:  RETLW  4D
00E6:  RETLW  44
00E7:  RETLW  3A
00E8:  RETLW  20
00E9:  RETLW  00
*
05E5:  BSF    03,5
05E6:  CLRF   32
05E7:  BCF    03,5
05E8:  BSF    03,5
05E9:  MOVF   32,W
05EA:  BCF    03,5
05EB:  CALL   0E0
05EC:  IORLW  00
05ED:  BTFSC  03,2
05EE:  GOTO   5F5
05EF:  BSF    03,5
05F0:  INCF   32,F
05F1:  MOVWF  3A
05F2:  BCF    03,5
05F3:  CALL   1C9
05F4:  GOTO   5E8
....................            BinToHexAscii( cCmd ); 
05F5:  BSF    03,5
05F6:  MOVF   30,W
05F7:  MOVWF  36
05F8:  BCF    03,5
05F9:  CALL   379
....................            LcdWrite( ' ' ); 
05FA:  MOVLW  20
05FB:  BSF    03,5
05FC:  MOVWF  3A
05FD:  BCF    03,5
05FE:  CALL   1C9
....................  
....................            if ( cLenOfData != 0 ) 
05FF:  BSF    03,5
0600:  MOVF   2F,F
0601:  BTFSS  03,2
0602:  GOTO   605
0603:  BCF    03,5
0604:  GOTO   61E
0605:  BCF    03,5
....................            { 
....................              for ( c=0; c<cLenOfData; c++ ) LcdWrite( cTest[c] ); 
0606:  BSF    03,5
0607:  CLRF   31
0608:  BCF    03,5
0609:  BSF    03,5
060A:  MOVF   2F,W
060B:  SUBWF  31,W
060C:  BTFSS  03,0
060D:  GOTO   610
060E:  BCF    03,5
060F:  GOTO   61E
0610:  BCF    03,5
0611:  MOVLW  A4
0612:  BSF    03,5
0613:  ADDWF  31,W
0614:  MOVWF  04
0615:  MOVF   00,W
0616:  MOVWF  32
0617:  MOVWF  3A
0618:  BCF    03,5
0619:  CALL   1C9
061A:  BSF    03,5
061B:  INCF   31,F
061C:  BCF    03,5
061D:  GOTO   609
....................            } 
....................  
....................            //Rs485SendPacket( SENSOR_ACK, 0, NULL ); 
....................            delay_ms(255); 
061E:  MOVLW  FF
061F:  BSF    03,5
0620:  MOVWF  3C
0621:  BCF    03,5
0622:  CALL   1A0
....................            Rs485Initialise(cOurAddrHigh,cOurAddrLow); 
0623:  MOVF   2E,W
0624:  BSF    03,5
0625:  MOVWF  32
0626:  BCF    03,5
0627:  MOVF   2F,W
0628:  BSF    03,5
0629:  MOVWF  33
062A:  BCF    03,5
062B:  CALL   25D
....................            ClearLine1(); 
....................            LcdWrite("Waiting........"); 
*
00EA:  BCF    0A,0
00EB:  BCF    0A,1
00EC:  BCF    0A,2
00ED:  ADDWF  02,F
00EE:  RETLW  57
00EF:  RETLW  61
00F0:  RETLW  69
00F1:  RETLW  74
00F2:  RETLW  69
00F3:  RETLW  6E
00F4:  RETLW  67
00F5:  RETLW  2E
00F6:  RETLW  2E
00F7:  RETLW  2E
00F8:  RETLW  2E
00F9:  RETLW  2E
00FA:  RETLW  2E
00FB:  RETLW  2E
00FC:  RETLW  2E
00FD:  RETLW  00
*
0642:  BSF    03,5
0643:  CLRF   32
0644:  BCF    03,5
0645:  BSF    03,5
0646:  MOVF   32,W
0647:  BCF    03,5
0648:  CALL   0EA
0649:  IORLW  00
064A:  BTFSC  03,2
064B:  GOTO   652
064C:  BSF    03,5
064D:  INCF   32,F
064E:  MOVWF  3A
064F:  BCF    03,5
0650:  CALL   1C9
0651:  GOTO   645
....................         } 
....................  
....................    } 
0652:  GOTO   535
....................  
.................... } 
....................  
0653:  SLEEP
....................  
.................... //************************** 
.................... // Setup  Hardware 
.................... //************************** 
.................... void Setup(void) 
.................... { 
....................     OPTIONREG = 0x84;             //  pullups,prescailer = TMR0 , rate = 1:32 
*
0200:  MOVLW  84
0201:  BSF    03,5
0202:  MOVWF  01
....................     INTCON = 0;                   // disable global interupts 
0203:  BCF    03,5
0204:  CLRF   0B
....................     ADCON1 = 0x07;                // Disable ADC 
0205:  MOVLW  07
0206:  BSF    03,5
0207:  MOVWF  1F
....................     TRISA = PortAConfig; 
0208:  CLRF   05
....................     TRISB = PortBConfig; 
0209:  CLRF   06
....................     TRISC = PortCConfig; 
020A:  MOVLW  0F
020B:  MOVWF  07
....................     TRISD = PortDConfig; 
020C:  CLRF   08
....................     TRISE = PortEConfig; 
020D:  CLRF   09
....................     PORTC = 0xFF; 
020E:  MOVLW  FF
020F:  BCF    03,5
0210:  MOVWF  07
....................     LCDSetup();                         // Setup the LCD Display 
....................     ConfigureComms();                  /* Configure USART for Asyncronous Comms */ 
....................     PORTC = 0xF7; 
*
0259:  MOVLW  F7
025A:  MOVWF  07
025B:  BCF    0A,3
025C:  GOTO   524
.................... } 
....................  
....................  
.................... //*******************************************************/ 
.................... //* Configure PIC16F87x USART for communications        */ 
.................... //*                                                     */ 
.................... //* Asynchronous mode                                   */ 
.................... //* 8 data bits  ( For other rates see PIC16F8XX Data ) */ 
.................... //* 1 stop bits                                         */ 
.................... //* No Parity                                           */ 
.................... //*                                                     */ 
.................... //*******************************************************/ 
.................... void ConfigureComms(void) 
.................... { 
....................     BIT_SET( RCSTA, SPEN );    // Enable Serial port 
*
024D:  BSF    18,7
....................     BIT_CLEAR( RCSTA, RX9 );   // 8 bit receive mode 
024E:  BCF    18,6
....................     BIT_CLEAR( TXSTA, TX9 );   // 8 bit transmit mode 
024F:  BSF    03,5
0250:  BCF    18,6
....................  
....................     // SPBRG = 0;              // SPBRG = 1  ( Set Baud rate 115,200 ) 
....................     // SPBRG = 5;              // SPBRG = 5  ( Set Baud rate 38,400 ) 
....................     // SPBRG = 22;             // SPBRG = 22 ( Set Baud rate 9,600 ) 
....................     // SPBRG = 11;             // SPBRG = 11 ( Set Baud rate 19,200 ) 
....................     // SPBRG = 22;             // SPBRG = 22 ( Set Baud rate 9,600 ) 
....................     // SPBRG = 47;             // SPBRG = 47 ( 9600 Baud at 7.3728 Mhx clock ) 
....................     // SPBRG = 22;             // SPBRG = 22 ( 9600 Baud at 3.579545Mhz clock ) 
....................  
....................     SPBRG = 25;                // SPBRG = 25 ( 9600 Baud at 4 Mhx clock ) 
0251:  MOVLW  19
0252:  MOVWF  19
....................  
....................     BIT_SET( TXSTA, BRGH );    // BRGH = 1   ( High speed mode ) 
0253:  BSF    18,2
....................     BIT_CLEAR( TXSTA, SYNC );  // Asyncronous mode; 
0254:  BCF    18,4
....................     BIT_SET( TXSTA, TXEN );    // Enable Transmitter 
0255:  BSF    18,5
....................     BIT_SET( RCSTA, CREN );    // Enable continuous receive 
0256:  BCF    03,5
0257:  BSF    18,4
....................     BIT_SET( INTCON, PEIE );   // Enable all Peripheral Interrupts 
0258:  BSF    0B,6
.................... } 
....................  
....................  
....................  
....................  
....................  
